---
layout: post
title: The importance of TDD
subtitle: Javascript Test Framwork, JEST
comments: true
tags: [NodeJS, Express, Jest, axios]
---

## Why it is worth investing your time in writing test code

Test Driven Developent, 즉 테스트 주도 개발은 필수 사항은 아니지만 테스트 코드를 작성함으로써 성공 및 실패 케이스를 모두 검증하여 우리의 어플리케이션이 원하는 대로 동작할 것이라는 자신감을 가질 수 있게 해준다. 실패하는 테스트 코드를 먼저 작성해두고 실제로 개발하면서 이 테스트에 통과할 수 있는 방향으로 코드를 작성하는 작업을 반복한다. 이렇게 해서 모든 테스트를 통과하면 리팩토링을 거쳐 이후에도 테스트에 성공할 수 있도록 만든다면 개발 코드의 퀄리티를 더욱 향상시킬 수 있다. 테스트 코드를 함께 레포에 merge하면 개발자들 간의 테스트 커버리지를 실시간으로 확인할 수 있기 때문에 문서화의 효과도 가진다. 이번 프로젝트에서는 자바스크립트의 테스트 프레임워크인 JEST 라이브러리를 사용하였다. [API 문서](https://jestjs.io/docs/api)에 설명이 잘 나와있으며 별도의 라이브러리만 추가하면 Typescript 환경에서도 지원이 된다는 점에서 매우 편리했다. 단위 테스트를 할 때에는 JEST가 제공하는 기능 중 모듈의 전체 혹은 일부를 mocking 할 수도 있다. 테스트 코드를 작성할 때 어떤 한 모듈이 내부적으로 사용하는, 즉 import 해오는 의존성이 있다면 그 외부 모듈 전체 혹은 부분을 테스트 코드에서 mock해주는 것인데(실제로 내가 처음에 사용한 방법이다.) 이는 모듈 간 의존성의 decoupling을 저해하고 부분적으로만 모듈의 기능들을 mocking 해야할 때에는 테스트 코드를 구현하는 것 역시 쉽지 않았다. 따라서 대안적으로 Stub의 방식을 채택해 리팩토링한 코드를 추가적으로 첨부하여 어떻게 나쁜 코드의 예제를 바꾸었는지의 과정을 보여줄 것이다. Stub은 개발 코드에서 외부 모듈을 import하는 것이 아닌 생성자 함수를 통해 주입받는 것이고 테스트 코드에서는 테스트 용으로 별도로 만들어 놓은 클래스의 객체를 주입받거나 빈 object를 주입받아 필요할 때마다 내부적으로 프로퍼티 메소드를 정의해 주는 것이다. 후자는 자바스크립트에서만 가능한 방법으로 나 역시 이 방식을 이용하였다. 결국 테스트 코드를 작성하다 보면 모듈의 의존성을 고려하게 되어 개발 코드의 퀄리티를 향상시킬 수 있다.

## Essential things to do before we start

타입스크립트로 Jest 라이브러리를 이용해 단위 테스트와 통합 테스트를 하기 위해서 추가해야하는 외부 의존성들은 다음과 같다.

- jest
- ts-jest, @types/jest
- node-mocks-http (단위 테스트를 할 때 가짜 http 요청 및 응답 객체를 생성할 수 있게 해줌)
- faker@5.5.3 (단위 테스트를 할 때 가짜 유저의 정보 등 mocking할 때 유용한 라이브러리, 현재 버전은 잘 작동하지 않아 이전 버전을 설치했음)
- axios(통합 테스트를 할 때 직접 서버에다가 http 요청을 하여 프로미스 형태의 응답을 받아올 수 있게 해줌)

또한 jest는 es6의 모듈과 잘 동작하지 않기 때문에 commonjs로 변환해주는 바벨 플러그인을 설치해 준 후 프로젝트 최상위 폴더 내부의 .babelrc 파일에 아래의 코드를 작성해주어야 한다.

**npm i --save-dev @babel/plugin-transform-modules-commonjs**

```json
{
	"env": {
		"test": {
			"plugins": ["@babel/plugin-transform-modules-commonjs"]
		}
	}
}
```

타입스크립트로 정의된 모든 test파일 내부에서 모듈을 import할 때에는 extension에 .js를 붙일 수 없다.
이렇게 두고 npm start를 하면 es6 모듈로 인식되는 자바스크립트 파일로 컴파일 된 후 서버를 실행시키에 오류가 발생하는데, commonjs 모듈과 달리 es6 모듈은 extension이 빠지면 안되기 때문이다. 따라서 jest.config.mjs에서 다음과 같은 추가적인 설정을 해줘야 한다. jest --init 명령어를 입력하면 jest.config.mjs 파일을 생성할 수 있다.

```json
{
	"extensionsToTreatAsEsm": [".ts"],
	"moduleNameMapper": {
		"^(\\.{1,2}/.*)\\.js$": "$1"
	},
	"transform": {
		"^.+\\.tsx?$": [
			"ts-jest",
			{
				"useESM": true
			}
		]
	}
}
```

그 다음은 테스트용 환경 변수 파일을 따로 만들어주는 것이다. **.env.test** 파일에 process.env에서 로드할 key와 value의 쌍들을 모두 적어주고 jest.config.mjs 파일의 setupFiles의 배열에 'dotenv/config'를 추가해준다. 이는 각각의 테스트 이전의 dotenv 모듈의 config 메소드를 실행하게 해준다. 그리고 package.json의 npm 명령어 정의 부분에서 테스트 종류 별로 테스트용 환경 변수 파일 위치를 명시해주는 DOTENV_CONFIG_PATH 옵션을 설정해준다. 윈도우의 경우 dev 모드로 cross-env를 설치한 후 명령어 앞 부분에 추가해주어야 정상적으로 작동한다. 

```json
"scripts": {
    "test": "cross-env DOTENV_CONFIG_PATH=./.env.test jest --watchAll --verbose --globalTeardown=./src/tests/global_teardown.ts",
    "test:unit": "cross-env DOTENV_CONFIG_PATH=./.env.test jest --watchAll --verbose --testPathIgnorePatterns='/src/tests, /dist'",
    "test:integration": "cross-env DOTENV_CONFIG_PATH=./.env.test jest --watchAll --verbose --testPathPattern=/src/tests --globalTeardown=./src/tests/global_teardown.ts",
    "start": "concurrently \"tsc -w\" nodemon dist/index"
  },
```
여기서 내가 사용한 몇 가지 옵션들에 대해 살펴보자. --watchAll은 테스트 파일에 변경사항이 생길 때마다 모든 테스트 파일을 다시 재실행하도록 해준다. --verbose는 실행된 테스트 파일별로 계층에 따라 개별적인 테스트의 결과(describe 혹은 test의 첫번째 인자로 넘겨주는 string 값)들을 출력해준다. --globalTeardown은 모든 테스트의 실행을 마친 후 데이터베이스 정리 작업을 해주는 등의 작업을 단 한번만 실행하도록 해준다. 단위 테스트에서는 db에 직접 접근하지 않기 때문에 tear down 작업을 해 줄 필요가 없다.

## Unit Test
유닛테스트는 하나의 함수, 모듈 혹은 클래스가 원하는 대로 동작하는 지를 검증하는 것이다. 예를 들어, User API 요청을 처리하는 각각의 서비스 별 controller의 실행 결과에 대해 성공과 실패 케이스 모두 테스트 코드를 작성할 수 있다. 

먼저 테스트의 대상이 되는 user.ts 파일의 코드를 살펴보자.

**/src/controller/user.ts**
```javascript
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import * as UserRepository from '../data/user.js';
import * as BugsRepository from '../data/bugs.js';
import * as CompanyRepository from '../data/companies.js';
import * as ProductRepository from '../data/products.js';
import { config } from '../config.js';
import { UserRegistration, UserLogin, ProductItem } from '../types/index.js';

export const createUser = async (
	req: Request,
	res: Response,
	next: NextFunction
) => {
	const { userName, password } = req.body as UserRegistration;
	const user = await UserRepository.findUserByName(userName);
	if (user) {
		return res.sendStatus(409);
	}

	const hashed = await bcrypt.hash(
		password,
		parseInt(config.bcrypt.saltsRound)
	);
	const userId = await UserRepository.createUser({
		...req.body,
		password: hashed,
	});

	const token = createJWT(userId);

	res.status(201).json({
		token,
		userName,
	});
}

export const login = async (req: Request, res: Response, next: NextFunction) => {
	const { userName, password } = req.body as UserLogin;
	const user = await UserRepository.findUserByName(userName);
	if (!user) return res.sendStatus(401);

	const match = await bcrypt.compare(password, user.password);
	if (!match) return res.sendStatus(401);

	const token = createJWT(user.id);

	res.status(200).json({
		token,
		userName,
	});
}

export async function remove(req: Request, res: Response, next: NextFunction) {
	await UserRepository.deleteUser(req.userId!);
	res.sendStatus(204);
}

export async function getMyPage(
	req: Request,
	res: Response,
	next: NextFunction
) {
	const { findUserById } = UserRepository;
	const {
		getNumberOfReservationsOfUser,
		getNumberOfInterestedCompaniesOfUser,
		getReservationItemsOfUser,
	} = CompanyRepository;
	const { getSurveyItemsOfUser } = BugsRepository;
	const { getProductItemsOfUser } = ProductRepository;

	const user = await findUserById(req.userId!);
	const accumulatedNumOfUsages = await getNumberOfReservationsOfUser(
		req.userId!
	);
	const numberOfInterestedCompanies =
		await getNumberOfInterestedCompaniesOfUser(req.userId!);
	const surveyList = await getSurveyItemsOfUser(req.userId!);
	const productList = await getProductItemsOfUser(req.userId!);
	const reservationList = await getReservationItemsOfUser(req.userId!);

	let updatedProductList;
	await Promise.all(
		productList.map(async (product) => {
			return updateNumOfInterestedUsers(product);
		})
	).then((result) => (updatedProductList = result));

	const userDetail = {
		...user,
		accumulatedNumOfUsages,
		numberOfInterestedCompanies,
		surveyList,
		updatedProductList,
		reservationList,
	};

	res.status(200).json(userDetail);
}

export function createJWT(userId: number): string {
	return jwt.sign({ userId }, config.jwt.privateKey, {
		expiresIn: config.jwt.expirSecs,
	});
}

async function updateNumOfInterestedUsers(
	product: ProductItem
): Promise<ProductItem> {
	const numOfUsers =
		await ProductRepository.getNumberOfInterestedUsersOfProduct(
			product.productId.toString()
		);
	product.numOfInterestedUsers = numOfUsers;
	return product;
}
```
위 코드에서 export 하는 컨트롤러 함수들은 각각 '회원가입', '로그인', '회원탈퇴', '마이페이지 정보 불러오기'를 위한 로직과 관련되어 있다. 여기서 눈 여겨 볼 것은 사용자, 벌레, 회사, 상품 db에 각각 접근하는 repository의 모듈들에 의존하고 있다는 사실이다. 위의 코드를 테스트 하기 위해서는 테스트 코드에서 각각의 모듈들을 jest.mock을 이용해 mocking 해야만 정상적으로 검증을 할 수 있다.

**/src/controller/test/user.test.ts**
```javascript
import httpMocks from 'node-mocks-http';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcrypt';
import * as userRepository from '../../data/user.js';
import * as companiesRepository from '../../data/companies.js';
import * as productsRepository from '../../data/products.js';
import * as bugsRepository from '../../data/bugs.js';
import { createUser, getMyPage, login, remove } from '../../controller/user.js';

jest.mock('bcrypt');
jest.mock('../../data/user');
jest.mock('../../data/companies');
jest.mock('../../data/products', () => {
	const originalModule = jest.requireActual('../../data/products');

	return {
		__esModule: true,
		...originalModule,
		getNumberOfInterestedUsersOfProduct: jest.fn(async () => '1'),
	};
});
jest.mock('../../data/bugs');

describe('User Controller', () => {
	it('create user', async () => {
		const registrationForm = {
			userName: faker.name.firstName(),
			password: faker.internet.password(),
			name: faker.name.fullName(),
			contactNumbers: faker.phone.number(),
			email: faker.internet.email(),
		};
		const request = httpMocks.createRequest({
			body: registrationForm,
		});
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'findUserByName')
			.mockImplementation(async () => undefined);

		jest.spyOn(userRepository, 'createUser').mockImplementation(async () => 1);

		await createUser(request, response, next);

		expect(response.statusCode).toBe(201);
		expect(response._getJSONData()).toMatchObject({
			userName: request.body.userName,
		});
		expect(response._getJSONData().token).toBeDefined();
	});

	it('return 409 if user already exists', async () => {
		const userName = faker.name.firstName();
		const password = faker.internet.password();
		const user = {
			id: faker.datatype.number(),
			userName,
			password,
			name: faker.name.fullName(),
			contactNumbers: faker.phone.number(),
			email: faker.internet.email(),
		};
		const registrationForm = {
			userName,
			password,
			name: faker.name.fullName(),
			contactNumbers: faker.phone.number(),
			email: faker.internet.email(),
		};
		const request = httpMocks.createRequest({
			body: registrationForm,
		});
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'findUserByName')
			.mockImplementation(async () => user);

		await createUser(request, response, next);

		expect(response.statusCode).toBe(409);
	});

	it('succeed to login', async () => {
		const userName = faker.name.firstName();
		const password = faker.internet.password();

		const user = {
			userName,
			password,
			id: faker.datatype.number(),
			name: faker.name.fullName(),
			contactNumbers: faker.phone.number(),
			email: faker.internet.email(),
		};
		const request = httpMocks.createRequest({
			body: {
				userName,
				password,
			},
		});
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'findUserByName')
			.mockImplementation(async () => user);

		jest.spyOn(bcrypt, 'compare').mockImplementation(async () => true);

		await login(request, response, next);

		expect(response.statusCode).toBe(200);
		expect(response._getJSONData()).toMatchObject({
			userName: request.body.userName,
		});
		expect(response._getJSONData().token).toBeDefined();
	});

	it('return 401 if user does not exist', async () => {
		const request = httpMocks.createRequest({
			userName: faker.name.firstName(),
			password: faker.internet.password(),
		});
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'findUserByName')
			.mockImplementation(async () => undefined);

		await login(request, response, next);

		expect(response.statusCode).toBe(401);
	});

	it('return 401 if password does not match', async () => {
		const userName = faker.name.firstName();
		const actualPassword = faker.internet.password();
		const fakePassword = faker.internet.password();
		const user = {
			id: faker.datatype.number(),
			userName,
			password: actualPassword,
			name: faker.name.fullName(),
			contactNumbers: faker.phone.number(),
			email: faker.internet.email(),
		};
		const request = httpMocks.createRequest({
			userName,
			password: fakePassword,
		});
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'findUserByName')
			.mockImplementation(async () => user);

		jest.spyOn(bcrypt, 'compare').mockImplementation(async () => false);

		await login(request, response, next);

		expect(response.statusCode).toBe(401);
	});

	it('delete a user', async () => {
		const request = httpMocks.createRequest();
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'deleteUser')
			.mockImplementation(async () => undefined);

		await remove(request, response, next);

		expect(response.statusCode).toBe(204);
	});

	it('load a user information', async () => {
		const user = {
			id: faker.datatype.number(),
			userName: faker.name.fullName(),
			password: faker.internet.password(),
			name: faker.name.fullName(),
			contactNumbers: faker.phone.number(),
			email: faker.internet.email(),
		};
		const numOfReservationsOfUser = faker.datatype.number({ min: 0, max: 30 });
		const numOfInterestedCompaniesOfUser = faker.datatype.number({
			min: 0,
			max: 30,
		});
		const surveyArray = [
			{
				surveyId: faker.datatype.number(),
				bugId: faker.datatype.number(),
				bugName: faker.animal.insect(),
				surveyDate: faker.date.recent(3).toString(),
			},
			{
				surveyId: faker.datatype.number(),
				bugId: faker.datatype.number(),
				bugName: faker.animal.insect(),
				surveyDate: faker.date.recent(3).toString(),
			},
		];
		const productArray = [
			{
				productInterestId: faker.datatype.number(),
				productId: faker.datatype.number(),
				userId: faker.datatype.number(),
				productName: faker.commerce.productName(),
				thumbnail: faker.internet.url(),
				numOfInterestedUsers: faker.datatype.number({ min: 0, max: 30 }),
			},
			{
				productInterestId: faker.datatype.number(),
				productId: faker.datatype.number(),
				userId: faker.datatype.number(),
				productName: faker.commerce.productName(),
				thumbnail: faker.internet.url(),
				numOfInterestedUsers: faker.datatype.number({ min: 0, max: 30 }),
			},
		];
		const reservationArray = [
			{
				reservationId: faker.datatype.number(),
				userId: faker.datatype.number(),
				companyName: faker.company.name(),
				bugName: faker.animal.insect(),
				processState: faker.datatype.number({ min: 0, max: 3 }),
				reservationDateTime: faker.date.recent(3).toString(),
				visitDateTime: faker.date.soon(3).toString(),
			},
			{
				reservationId: faker.datatype.number(),
				userId: faker.datatype.number(),
				companyName: faker.company.name(),
				bugName: faker.animal.insect(),
				processState: faker.datatype.number({ min: 0, max: 3 }),
				reservationDateTime: faker.date.recent(3).toString(),
				visitDateTime: faker.date.soon(3).toString(),
			},
		];

		const request = httpMocks.createRequest();
		const response = httpMocks.createResponse();
		const next = jest.fn();

		jest
			.spyOn(userRepository, 'findUserById')
			.mockImplementation(async () => user);

		jest
			.spyOn(companiesRepository, 'getNumberOfReservationsOfUser')
			.mockImplementation(async () => numOfReservationsOfUser);

		jest
			.spyOn(companiesRepository, 'getNumberOfInterestedCompaniesOfUser')
			.mockImplementation(async () => numOfInterestedCompaniesOfUser);

		jest
			.spyOn(bugsRepository, 'getSurveyItemsOfUser')
			.mockImplementation(async () => surveyArray);

		jest
			.spyOn(productsRepository, 'getProductItemsOfUser')
			.mockImplementation(async () => productArray);

		jest
			.spyOn(companiesRepository, 'getReservationItemsOfUser')
			.mockImplementation(async () => reservationArray);

		await getMyPage(request, response, next);

		const userDetail = {
			...user,
			accumulatedNumOfUsages: numOfReservationsOfUser,
			numberOfInterestedCompanies: numOfInterestedCompaniesOfUser,
			surveyList: surveyArray,
			updatedProductList: productArray,
			reservationList: reservationArray,
		};

		expect(response.statusCode).toBe(200);
		expect(response._getJSONData()).toMatchObject(userDetail);
	});
});
```
유닛테스트의 대상이 되는 컨트롤러 함수인 createUser, getMyPage, login, remove를 모두 import 해왔다. user.ts에서 내부적으로 의존하고 있는 외부 모듈들 역시 import 하는 동시에 jest.mock(경로명)을 통해 모듈 전체를 mocking 할 거라고 선언해주고 jest.spyOn(레포지토리명, 'API 명').mockImplementation(...)을 통해 함수의 구현 사항을 mocking 했다. 위의 파일들은 모듈 간 의존성이 강하고 테스트 구현이 복잡하다는 단점이 있다. 따라서 인트로에서 언급했듯이 stub의 방식을 통해 리팩토링 해보았다. 

**/src/controller/user.ts (refactoring)**
**/src/controller/test/user.test.ts (refactoring)**


## Integration test

유닛 테스트
todo
auth 미들웨어
기능별 컨트롤러

서버 생성 함수, 종료 함수를 분리하는데 성공. 테스트 환경에서 포트를 따로 지정하지 않게 설정.
이슈 : 테스트할 때마다 fake data가 insert되어 기존 데이터베이스가 pollunated되는데 얘는 어떻게 하면 좋을까?
통합 테스트(서버를 직접 시작하고 직접 중단할 수 있는 함수를 생성)

- 회원가입, 로그인 api
- 상품 전체 불러오기, 상품 하나 불러오기
- user db 정리하기
